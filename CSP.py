# -*- coding: utf-8 -*-
"""Untitled16.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1oSK5qfEEx1jT-q2-215ecT0ZRG-XfIEN
"""

!pip install python-constraint

from constraint import *

n=3

problem = Problem()

problem.addVariables(range(0, n*n), range(1, n*n + 1))

problem.addConstraint(AllDifferentConstraint(), range(0, n*n))

exactproduct =

import itertools

def cryptarithmetic_solver(equation):
    # Split the equation into left and right parts
    left_side, right_side = equation.split('=')
    left_terms = left_side.split('+')

    # Collect unique characters from the equation
    unique_chars = set(''.join(left_terms) + right_side)

    if len(unique_chars) > 10:
        return "No solution exists: More than 10 unique letters."

    # Generate all possible digit assignments
    for digits in itertools.permutations(range(10), len(unique_chars)):
        char_to_digit = dict(zip(unique_chars, digits))

        # Function to replace letters in a term with their corresponding digits
        def replace_term(term):
            return int(''.join(str(char_to_digit[char]) for char in term))

        # Calculate the left side and right side
        left_sum = sum(replace_term(term) for term in left_terms)
        right_value = replace_term(right_side)

        # Check if the equation is satisfied
        if left_sum == right_value:
            return {char: char_to_digit[char] for char in unique_chars}

    return "No solution exists."

# Example usage
equation = "SEND+MORE=MONEY"
solution = cryptarithmetic_solver(equation)
print(solution)